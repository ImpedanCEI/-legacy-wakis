'''
---------------------
| WAKIS plot module |
---------------------
Auxiliary functions for WAKIS results plotting

Functions: [TODO]
---------
- a
- b
- c

Requirements:
------------- 
pip install matplotlib, numpy, h5py, scipy
'''
import os 
import pickle as pk

import numpy as np
import matplotlib.pyplot as plt
import scipy.constants as spc  
import h5py as h5py

# Global variables
UNIT = 1e-3 #conversion to m
CST_PATH = '/mnt/c/Users/elefu/Documents/CERN/WAKIS/Scripts/CST/' 
OUT_PATH = os.getcwd() + '/' +'runs/out/'

# Plot global parameters
plt.rcParams.update({'font.size': 12})

def read_WarpX(out_path=OUT_PATH):
    '''
    Read the input_data.txt file containing WarpX simulation inputs
    '''
    with open(out_path+'input_data.txt', 'rb') as handle:
        input_data = pk.loads(handle.read())
    return input_data

def read_CST(cst_out_path=CST_PATH):
    '''
    Read the cst_out.txt file containing the benchmark variables
    '''
    if os.path.exists(cst_out_path+'cst_out.txt'):
        with open(cst_out_path+'cst_out.txt', 'rb') as handle:
            cst_data = pk.loads(handle.read())
    else: cst_data = None 

    return cst_data

def read_WAKIS(out_path=OUT_PATH):
    '''
    Read the wake_solver.txt file generated by WAKIS
    '''
    if os.path.exists(out_path+'wake_solver.txt'):

        with open(out_path+'wake_solver.txt', 'rb') as handle:
            wakis_data = pk.loads(handle.read())
    else: wakis_data=None 

    return wakis_data 

def read_Ez(out_path, filename='Ez.h5'):
    '''
    Read the Ez.h5 file generated by WarpX simulation
    '''
    hf = h5py.File(out_path+filename, 'r')
    print('Reading the h5 file: '+ out_path+filename)
    print('--- Size of the file: '+str(round((os.path.getsize(out_path+filename)/10**9),2))+' Gb')

    # get number of datasets
    size_hf=0.0
    dataset=[]

    for key in hf.keys():
        size_hf+=1
        dataset.append(key)

    # get size of matrix
    Ez=hf.get(dataset[0])
    shapex=Ez.shape[0]  
    shapey=Ez.shape[1] 
    shapez=Ez.shape[2] 
    print('--- Ez field is stored in a matrix with shape '+str(Ez.shape)+' in '+str(int(size_hf))+' datasets')

    return hf, dataset

def animate_Ez(out_path, filename='Ez.h5', flag_charge_dist=True, flag_compare_cst=False, flag_transverse_field=False):
    '''
    Creates an animated plot showing the Ez field along the z axis for every timestep
    -flag_charge_dist=True [def]: plots the passing beam charge distribution 
    -flag_compare_cst=True : add the comparison with CST field in cst dict
    -flag_transverse_field=True : add the Ez field in adjacent transverse cells Ez1(0+dx, 0+dy, z), Ez2(0+2dx, 0+2dy, z)
    '''

    # Read data
    hf, dataset = read_Ez(out_path, filename)
    data =  read_WarpX(out_path)

    t = data.get('t')               #simulated time [s]
    z = data.get('z')               #z axis values  [m]
    charge_dist = data.get('charge_dist')
    z0 = data.get('z0')             #full domain length (+pmls) [m]

    # Extract field on axis Ez (z,t)
    Ez0=[]
    for n in range(len(dataset)):
        Ez=hf.get(dataset[n]) # [V/m]
        Ez0.append(np.array(Ez[Ez.shape[0]//2, Ez.shape[1]//2,:])) # [V/m]

    Ez0=np.transpose(np.array(Ez0))

    if flag_transverse_field:
        Ez1=[]
        Ez2=[]
        for n in range(len(dataset)):
            Ez=hf.get(dataset[n]) # [V/m]
            Ez1.append(np.array(Ez[Ez.shape[0]//2+1, Ez.shape[1]//2+1,:])) # 1st adjacent cell Ez [V/m]
            Ez2.append(np.array(Ez[Ez.shape[0]//2+2, Ez.shape[1]//2+2,:])) # 2nd adjacent cell Ez [V/m]

        Ez1=np.transpose(np.array(Ez1))
        Ez2=np.transpose(np.array(Ez2))

    plt.ion()
    n=0
    for n in range(10,1000):
        if n % 1 == 0:
            #--- Plot Ez along z axis 
            fig = plt.figure(1, figsize=(6,4), dpi=200, tight_layout=True)
            ax=fig.gca()
            ax.plot(np.array(z0)*1.0e3, charge_dist[:,n]/np.max(charge_dist)*np.max(Ez0)*0.4, lw=1.3, color='r', label='$\lambda $') 
            ax.plot(z*1e3, Ez0[:, n], color='g', label='Ez(0,0,z) WarpX')

            if flag_transverse_field:
                ax.plot(z*1e3, Ez1[:, n], color='seagreen', label='Ez(0+dx, 0+dy, z) WarpX')
                ax.plot(z*1e3, Ez2[:, n], color='limegreen', label='Ez(0+2dx, 0+2dy, z) WarpX')

            if flag_compare_cst:
                try:
                    cst_data=read_CST(CST_PATH)
                    z_cst=cst_data.get('z_cst')
                    Ez_cst=cst_data.get('Ez_cst')
                    ax.plot(z_cst*1e3, Ez_cst[:, n], lw=1.0, color='black', ls='--',label='Ez(0,0,z) CST')
                except: 
                    print('Warning: macro CST_PATH is not well defined')

            ax.set(title='Electric field at time = '+str(round(t[n]*1e9,2))+' ns | timestep '+str(n),
                    xlabel='z [mm]',
                    ylabel='E [V/m]',         
                    ylim=(-np.max(Ez0)*1.1,np.max(Ez0)*1.1),
                    xlim=(min(z)*1e3,max(z)*1e3),
                            )
            ax.legend(loc='best')
            ax.grid(True, color='gray', linewidth=0.2)
            fig.canvas.draw()
            fig.canvas.flush_events()
            fig.clf()
    plt.close()

def contour_Ez(out_path, filename='Ez.h5', vmin=-1.0e5, vmax=1.0e5):
    '''
    Creates an animated contour of the Ez field in the Y-Z plane at x=0
    -vmin=-1.0e5 [def]: minimum value of the colorbar
    -vmax=+1.0e5 [def]: maximum value of the colorbar
    '''

    # Read data
    hf, dataset = read_Ez(out_path, filename)
    data =  read_WarpX(out_path)

    t = data.get('t')       #simulated time [s]
    z = data.get('z')       #z axis masked values [m]
    y = data.get('y0')      #y axis domain values [m]

    # Check for 3d field
    Ez=hf.get(dataset[0])
    if Ez.shape[1] < 8:
        raise Exception("Ez field not stored in 3D, contour will not render -> check simulation script")

    else:
        plt.ion()
        for n in range(len(dataset)):
            Ez=hf.get(dataset[n])
            fig = plt.figure(1, figsize=(6,4), dpi=200, tight_layout=True)
            ax=fig.gca()
            im=ax.imshow(Ez[int(Ez.shape[0]/2),:,:], vmin=vmin, vmax=vmax, extent=[min(z)*1e3, max(z)*1e3, min(y)*1e3, max(y)*1e3], cmap='jet')
            ax.set(title='WarpX Ez field, t = ' + str(round(t[n]*1e9,3)) + ' ns',
                   xlabel='z [mm]',
                   ylabel='y [mm]'
                   )
            plt.colorbar(im, label = 'Ez [V/m]')
            fig1.canvas.draw()
            fig1.canvas.flush_events()
            fig1.clf() 

        plt.close()


def plot_charge_dist(data=read_WAKIS(out_path=OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=True):
    # Obtain WAKIS variables
    s = data.get('s')
    q = data.get('q')
    lambdas = data.get('lambda') #[C/m]

    # Obtain CST variables
    lambda_cst=cst_data.get('charge_dist') #[C/m]
    s_cst=cst_data.get('s_charge_dist')

    # Plot charge distribution λ(s) & comparison with CST 
    fig = plt.figure(1, figsize=(8,5), dpi=150, tight_layout=True)
    ax=fig.gca()
    ax.plot(s*1.0e3, lambdas, lw=1.2, color='red', label='$\lambda$(s)')
    if flag_compare_cst:
        ax.plot(s_cst*1.0e3, lambda_cst, lw=1, color='red', ls='--', label='$\lambda$(s) CST')
    ax.set(title='Charge distribution $\lambda$(s)',
            xlabel='s [mm]',
            ylabel='$\lambda$(s) [C/m]',
            xlim=(min(s*1.0e3), np.max(s*1.0e3))
            )
    ax.legend(loc='best')
    ax.grid(True, color='gray', linewidth=0.2)
    plt.show()

    return fig

def plot_long_WP(data=read_WAKIS(out_path=OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=True):
    # Obtain WAKIS variables
    WP=data.get('WP')
    s=data.get('s')

    # Obtain CST variables
    WP_cst=cst_data.get('WP_cst')
    s_cst=cst_data.get('s_cst')

    # Plot longitudinal wake potential W||(s) & comparison with CST 
    fig = plt.figure(1, figsize=(8,5), dpi=150, tight_layout=True)
    ax=fig.gca()
    ax.plot(s*1.0e3, WP, lw=1.2, color='orange', label='$W_{||}$(s) from WAKIS')
    if flag_compare_cst:
        ax.plot(s_cst*1e3, WP_cst, lw=1.2, color='black', ls='--', label='$W_{||}$(s) CST')
    ax.set(title='Longitudinal Wake potential $W_{||}$(s)',
            xlabel='s [mm]',
            ylabel='$W_{||}$(s) [V/pC]',
            xlim=(min(s*1.0e3), np.amin((np.max(s*1.0e3), np.max(s_cst*1.0e3)))),
            ylim=(min(WP)*1.2, max(WP)*1.2)
            )
    ax.legend(loc='lower right')
    ax.grid(True, color='gray', linewidth=0.2)
    plt.show()

    return fig

def plot_long_Z(data=read_WAKIS(out_path=OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=False, 
                flag_normalize=False, flag_plot_Real=False, flag_plot_Imag=False, flag_plot_Abs=True):
    # Obtain wakis variables
    Z=data.get('Z')
    f=data.get('f')

    if np.iscomplex(Z[1]):
        ReZ=np.real(Z)
        ImZ=np.imag(Z)
        Z=abs(Z)

    # Obtain CST variables
    Z_cst=cst_data.get('Z_cst')
    freq_cst=cst_data.get('freq_cst')
    ReZ_cst=cst_data.get('ReZ')
    ImZ_cst=cst_data.get('ImZ')

    # Plot longitudinal impedance Z||(w) comparison with CST [normalized]
    #---normalizing factor between CST and in numpy.fft
    if flag_normalize:
        norm=max(Z_cst)/max(Z) 
        title='Longitudinal impedance Z||(w) \n [normalized by '+str(round(norm,3))+']'
    else:
        norm=1.0
        title='Longitudinal impedance Z||(w)'

    fig = plt.figure(2, figsize=(8,5), dpi=150, tight_layout=True)
    ax=fig.gca()
    #--- obtain the maximum frequency for CST and plot

    #--- obtain the maximum frequency and plot Z||(s)
    if flag_plot_Real:
        if flag_compare_cst:
            try:
                ax.plot(freq_cst*1e-9, ReZ_cst, lw=1, ls='--', color='r', label='Real Z||(w) from CST')
            except: print('Real Z is not stores in cst dict')
        ax.plot(f*1e-9, ReZ, lw=1, color='r', marker='v', markersize=2., label='Real Z||(w) from WAKIS')

    if flag_plot_Imag:
        if flag_compare_cst:
            try:
                ax.plot(freq_cst*1e-9, ImZ_cst, lw=1, ls='--', color='g', label='Imag Z||(w) from CST')
            except: print('Imag Z is not stores in cst dict')
        ax.plot(f*1e-9, ImZ, lw=1, color='g', marker='s', markersize=2., label='Imag Z||(w) from WAKIS')

    if flag_plot_Abs:
        if flag_compare_cst:
            ifmax=np.argmax(Z_cst)
            ax.plot(freq_cst[ifmax]*1e-9, Z_cst[ifmax], marker='o', markersize=5.0, color='red')
            ax.annotate(str(round(freq_cst[ifmax]*1e-9,2))+ ' GHz', xy=(freq_cst[ifmax]*1e-9,Z_cst[ifmax]), xytext=(+10,0), textcoords='offset points', color='red') 
            ax.plot(freq_cst*1.0e-9, Z_cst, lw=1, color='red', marker='s', markersize=1., label='Z||(w) from CST')
        ifmax=np.argmax(Z)
        ax.plot(f[ifmax]*1e-9, Z[ifmax], marker='o', markersize=4.0, color='blue')
        ax.annotate(str(round(f[ifmax]*1e-9,2))+ ' GHz', xy=(f[ifmax]*1e-9,Z[ifmax]), xytext=(-20,5), textcoords='offset points', color='blue') 
        ax.plot(f*1e-9, Z, lw=1, color='b', marker='s', markersize=2., label='Z||(w) from WAKIS')
    
    ax.set( title=title,
            xlabel='f [GHz]',
            ylabel='Z||(w) [$\Omega$]',   
            #ylim=(0.,np.max(Z)*1.2),
            xlim=(0.,np.max(f)*1e-9)      
            )
    ax.legend(loc='upper left')
    ax.grid(True, color='gray', linewidth=0.2)
    plt.show()

    return fig


def plot_trans_WP(data=read_WAKIS(out_path=OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=True):
    # Obtain wakis variables
    WPx=data.get('WPx')
    WPy=data.get('WPy')
    s=data.get('s')
    # Obtain the offset of the source beam and test beam
    xsource=data.get('xsource')
    ysource=data.get('ysource')
    xtest=data.get('xtest')
    ytest=data.get('ytest') 

    # Obtain CST variables
    WPx_cst=cst_data.get('WPx_cst')
    WPy_cst=cst_data.get('WPy_cst')
    s_cst=cst_data.get('s_cst')

    #-- Quadrupolar cases
    if xtest != 0.0 and ytest == 0.0:
        WPx_cst=cst_data.get('WPx_quadrupolarX_cst')
        WPy_cst=cst_data.get('WPy_quadrupolarX_cst')
        s_cst=cst_data.get('s_cst_quadrupolar')
    if xtest == 0.0 and ytest != 0.0:
        WPx_cst=cst_data.get('WPx_quadrupolarY_cst')
        WPy_cst=cst_data.get('WPy_quadrupolarY_cst')
        s_cst=cst_data.get('s_cst_quadrupolar')
    if xtest != 0.0 and ytest != 0.0:
        WPx_cst=cst_data.get('WPx_quadrupolar_cst')
        WPy_cst=cst_data.get('WPy_quadrupolar_cst')
        s_cst=cst_data.get('s_cst_quadrupolar')

    #-- Dipolar cases
    if xsource != 0.0 and ysource == 0.0:
        WPx_cst=cst_data.get('WPx_dipolarX_cst')
        WPy_cst=cst_data.get('WPy_dipolarX_cst')
        s_cst=cst_data.get('s_cst_dipolar')
    if xsource == 0.0 and ysource != 0.0:
        WPx_cst=cst_data.get('WPx_dipolarY_cst')
        WPy_cst=cst_data.get('WPy_dipolarY_cst')
        s_cst=cst_data.get('s_cst_dipolar')
    if xsource != 0.0 and ysource != 0.0:
        WPx_cst=cst_data.get('WPx_dipolar_cst')
        WPy_cst=cst_data.get('WPy_dipolar_cst')
        s_cst=cst_data.get('s_cst_dipolar')

    # Plot transverse wake potential Wx⊥(s), Wy⊥(s) & comparison with CST
    fig = plt.figure(3, figsize=(8,5), dpi=150, tight_layout=True)
    ax=fig.gca()
    if flag_compare_cst:
        ax.plot(s_cst*1.0e3, WPx_cst, lw=1, color='g', ls='--', label='Wx⊥(s) from CST')
    ax.plot(s*1.0e3, WPx, lw=1.2, color='g', label='Wx⊥(s) from WAKIS')
    if flag_compare_cst:
        ax.plot(s_cst*1.0e3, WPy_cst, lw=1, color='magenta', ls='--', label='Wy⊥(s) from CST')
    ax.plot(s*1.0e3, WPy, lw=1.2, color='magenta', label='Wy⊥ from WAKIS(s)')
    ax.set(title='Transverse Wake potential W⊥(s) \n xsource, ysource = '+str(xsource*1e3)+' mm | xtest, ytest = '+str(xtest*1e3)+' mm',
            xlabel='s [mm]',
            ylabel='$W_{⊥}$ [V/pC]',
            xlim=(min(s*1.0e3), np.max(s*1.0e3)),
            )
    ax.legend(loc='best')
    ax.grid(True, color='gray', linewidth=0.2)
    plt.show()

    return fig

def plot_trans_Z(data=read_WAKIS(out_path=OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=True, flag_normalize=True):
    # Obtain wakis variables
    Zx=data.get('Zx')
    Zy=data.get('Zy')
    freqx=data.get('f')
    freqy=data.get('f')

    if np.iscomplex(Zx[1]):
        ReZx=np.real(Zx)
        ImZx=np.imag(Zx)
        Zx=abs(Zx)

    if np.iscomplex(Zy[1]):
        ReZy=np.real(Zy)
        ImZy=np.imag(Zy)
        Zy=abs(Zy)

    # Obtain the offset of the source beam and test beam
    xsource=data.get('xsource')
    ysource=data.get('ysource')
    xtest=data.get('xtest')
    ytest=data.get('ytest') 

    # Obtain CST variables
    Zx_cst=cst_data.get('Zx_cst')
    Zy_cst=cst_data.get('Zy_cst')
    freq_cst=cst_data.get('freq_cst')

    #-- Quadrupolar cases
    if xtest != 0.0 and ytest == 0.0:
        Zx_cst=cst_data.get('Zx_quadrupolarX_cst')
        Zy_cst=cst_data.get('Zy_quadrupolarX_cst')
        freq_cst=cst_data.get('freq_cst_quadrupolar')
    if xtest == 0.0 and ytest != 0.0:
        Zx_cst=cst_data.get('Zx_quadrupolarY_cst')
        Zy_cst=cst_data.get('Zy_quadrupolarY_cst')
        freq_cst=cst_data.get('freq_cst_quadrupolar')
    if xtest != 0.0 and ytest != 0.0:
        Zx_cst=cst_data.get('Zx_quadrupolar_cst')
        Zy_cst=cst_data.get('Zy_quadrupolar_cst')
        freq_cst=cst_data.get('freq_cst_quadrupolar')

    #-- Dipolar cases
    if xsource != 0.0 and ysource == 0.0:
        Zx_cst=cst_data.get('Zx_dipolarX_cst')
        Zy_cst=cst_data.get('Zy_dipolarX_cst')
        freq_cst=cst_data.get('freq_cst_dipolar')
    if xsource == 0.0 and ysource != 0.0:
        Zx_cst=cst_data.get('Zx_dipolarY_cst')
        Zy_cst=cst_data.get('Zy_dipolarY_cst')
        freq_cst=cst_data.get('freq_cst_dipolar')
    if xsource != 0.0 and ysource != 0.0:
        Zx_cst=cst_data.get('Zx_dipolar_cst')
        Zy_cst=cst_data.get('Zy_dipolar_cst')
        freq_cst=cst_data.get('freq_cst_dipolar')

    #--- normalizing factor between CST and in wakis results
    if flag_normalize:
        norm_x=max(Zx_cst)/max(Zx) 
        norm_y=max(Zy_cst)/max(Zy) 
        title='Transverse impedance Z⊥(w) [normalized by '+str(round(norm_x,3))+']'
    else:
        norm_x=1.0
        norm_y=1.0
        title='Transverse impedance Z⊥(w)'

    #--- obtain the maximum frequency
    ifxmax=np.argmax(Zx)
    ifymax=np.argmax(Zy)

    fig = plt.figure(4, figsize=(8,5), dpi=150, tight_layout=True)
    ax=fig.gca()

    #--- plot Zx⊥(w)
    if flag_compare_cst:
        ifmax=np.argmax(Zx_cst)
        ax.plot(freq_cst[ifmax]*1e-9, Zx_cst[ifmax], marker='o', markersize=5.0, color='black')
        ax.annotate(str(round(freq_cst[ifmax]*1e-9,2))+ ' GHz', xy=(freq_cst[ifmax]*1e-9,Zx_cst[ifmax]), xytext=(+5,-5), textcoords='offset points', color='black') 
        ax.plot(freq_cst*1.0e-9, Zx_cst, lw=1, ls='--', color='black', label='Zx⊥(w) from CST')

    ax.plot(freqx[ifxmax]*1e-9, Zx[ifxmax]*norm_x, marker='o', markersize=4.0, color='green')
    ax.annotate(str(round(freqx[ifxmax]*1e-9,2))+ ' GHz', xy=(freqx[ifxmax]*1e-9,Zx[ifxmax]), xytext=(-50,-5), textcoords='offset points', color='green') 
    ax.plot(freqx*1e-9, Zx*norm_x, lw=1, color='g', marker='s', markersize=2., label='Zx⊥(w) from WAKIS')

    #--- plot Zy⊥(w)
    if flag_compare_cst:
        ifmax=np.argmax(Zy_cst)
        ax.plot(freq_cst[ifmax]*1e-9, Zy_cst[ifmax], marker='o', markersize=5.0, color='black')
        ax.annotate(str(round(freq_cst[ifmax]*1e-9,2))+ ' GHz', xy=(freq_cst[ifmax]*1e-9,Zy_cst[ifmax]), xytext=(+5,-5), textcoords='offset points', color='black') 
        ax.plot(freq_cst*1.0e-9, Zy_cst, lw=1, ls='--', color='black', label='Zy⊥(w) from CST')

    ax.plot(freqy[ifymax]*1e-9, Zy[ifymax]*norm_y, marker='o', markersize=4.0, color='magenta')
    ax.annotate(str(round(freqy[ifymax]*1e-9,2))+ ' GHz', xy=(freqy[ifymax]*1e-9,Zy[ifymax]), xytext=(-50,-5), textcoords='offset points', color='magenta') 
    ax.plot(freqy*1e-9, Zy*norm_y, lw=1, color='magenta', marker='s', markersize=2., label='Zy⊥(w) from WAKIS')
    ax.set(title=title,
            xlabel='f [GHz]',
            ylabel='Z⊥(w) [$\Omega$]',   
            #ylim=(0.,np.max(Zx_cst)*1.2),
            xlim=(0.,np.max(freqx)*1e-9)      
            )
    ax.legend(loc='best')
    ax.grid(True, color='gray', linewidth=0.2)
    plt.show()

    return fig

def plot_WAKIS(data=read_WAKIS(OUT_PATH), cst_data=read_CST(CST_PATH), flag_compare_cst=True, flag_normalize=False, flag_charge_dist=False,
            flag_plot_Real=False, flag_plot_Imag=False, flag_plot_Abs=True):
    '''
    Plot results of WAKIS wake solver in different figures

    Parameters
    ---------- 
    - data: [default] data=read_WAKIS(OUT_PATH). Dictionary containing the wake solver output
    - cst_data: [default] cst_data=read_CST(CST_PATH). Dictionary containing the CST benchmark variables
    - flag_compare_cst: [default] True. Enables comparison with CST data 
    - flag_normalize: [default] False. Normalizes the shunt impedance to CST value
    - flag_charge_dist: [default] False. Plots the charge distribution as a function of s 

    Returns
    -------
    - fig 1-4: if flag_charge_dist=False 
    or
    - fig 1-5: if flag_charge_dist=True
    
    fig1 = plot_long_WP
    fig2 = plot_long_Z
    fig3 = plot_trans_WP
    fig4 = plot_trans_Z
    fig5 = plot_charge_dist

    '''
    fig1 = plot_long_WP(data=data, cst_data=cst_data, flag_compare_cst=flag_compare_cst)
    fig2 = plot_long_Z(data=data, cst_data=cst_data, flag_compare_cst=flag_compare_cst, flag_normalize=flag_normalize, flag_plot_Real=flag_plot_Real, flag_plot_Imag=flag_plot_Imag, flag_plot_Abs=flag_plot_Abs)
    fig3 = plot_trans_WP(data=data, cst_data=cst_data, flag_compare_cst=flag_compare_cst)
    fig4 = plot_trans_Z(data=data, cst_data=cst_data, flag_compare_cst=flag_compare_cst, flag_normalize=flag_normalize)

    if flag_charge_dist:
        fig5 = plot_charge_dist(data=data, cst_data=cst_data, flag_compare_cst=flag_compare_cst)
        return fig1, fig2, fig3, fig4, fig5
    else: 
        return fig1, fig2, fig3, fig4 

def subplot_WAKIS(data=read_WAKIS(OUT_PATH), flag_charge_dist=False, flag_plot_Real=False, flag_plot_Imag=False, flag_plot_Abs=True):
    '''
    Plot results of WAKIS wake solver in the same figure

    Parameters
    ---------- 
    - data = [default] read_WAKIS(OUT_PATH). Dictionary containing the wake solver output
    - flag_charge_dist = [default] False : Plots norm. charge distribution on top of the wake potential
    - flag_plot_Real = [default] False : Adds the real part of the impedance Z to the plot
    - flag_plot_Imag = [default] False : Adds the imaginary part of the impedance Z to the plot
    - flag_plot_Abs  = [default] True : Adds the magnitude of the impedance Z to the plot

    Returns
    -------
    - fig: figure object

    '''  
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
    fig.set_size_inches(16, 10)

    # Add title
    xsource=data.get('xsource')
    ysource=data.get('ysource')
    xtest=data.get('xtest')
    ytest=data.get('ytest') 

    plt.text(x=0.5, y=0.96, s="WAKIS wake solver result", fontsize='x-large', fontweight='bold', ha="center", transform=fig.transFigure)
    plt.text(x=0.5, y=0.93, s= 'xsource = '+str(xsource*1e3)+' mm , ysource = '+str(ysource*1e3)+'mm | xtest = '+str(xtest*1e3)+' mm , ytest = '+str(ytest*1e3)+'mm', fontsize='large', ha="center", transform=fig.transFigure)

    # Longitudinal WP
    WP=data.get('WP')
    s=data.get('s')

    ax1.plot(s*1.0e3, WP, lw=1.2, color='orange', label='$W_{||}$(s)')

    if flag_charge_dist:
        lambdas = data.get('lambda')
        ax1.plot(s*1.0e3, lambdas*max(WP)/max(lambdas), lw=1, color='red', label='$\lambda$(s) [norm]')

    ax1.set(title='Longitudinal Wake potential $W_{||}$(s)',
            xlabel='s [mm]',
            ylabel='$W_{||}$(s) [V/pC]',
            )
    ax1.legend(loc='best')
    ax1.grid(True, color='gray', linewidth=0.2)

    # Longitudinal Z
    Z=data.get('Z')
    f=data.get('f')

    if np.iscomplex(Z[1]):
        ReZ=np.real(Z)
        ImZ=np.imag(Z)
        Z=abs(Z)

    if flag_plot_Real:
        ax2.plot(f*1e-9, ReZ, lw=1, ls='--', color='r', marker='s', markersize=2., label='Real Z||(w)')

    if flag_plot_Imag:
        ax2.plot(f*1e-9, ImZ, lw=1, ls='--', color='g', marker='s', markersize=2., label='Imag Z||(w)')

    if flag_plot_Abs:
        ifmax=np.argmax(Z)
        ax2.plot(f[ifmax]*1e-9, Z[ifmax], marker='o', markersize=4.0, color='blue')
        ax2.annotate(str(round(f[ifmax]*1e-9,2))+ ' GHz', xy=(f[ifmax]*1e-9,Z[ifmax]), xytext=(-20,5), textcoords='offset points', color='blue') 
        ax2.plot(f*1e-9, Z, lw=1, color='b', marker='s', markersize=2., label='Z||(w)')

    ax2.set(title='Longitudinal impedance Z||(w)',
            xlabel='f [GHz]',
            ylabel='Z||(w) [$\Omega$]',   
            #ylim=(0.,np.max(Z)*1.2),
            xlim=(0.,np.max(f)*1e-9)      
            )
    ax2.legend(loc='best')
    ax2.grid(True, color='gray', linewidth=0.2)

    # Transverse WP    
    WPx=data.get('WPx')
    WPy=data.get('WPy')

    ax3.plot(s*1.0e3, WPx, lw=1.2, color='g', label='Wx⊥(s)')
    ax3.plot(s*1.0e3, WPy, lw=1.2, color='magenta', label='Wy⊥(s)')
    ax3.set(title='Transverse Wake potential W⊥(s)',
            xlabel='s [mm]',
            ylabel='$W_{⊥}$ [V/pC]',
            )
    ax3.legend(loc='best')
    ax3.grid(True, color='gray', linewidth=0.2)

    # Transverse Z
    Zx=data.get('Zx')
    Zy=data.get('Zy')

    if np.iscomplex(Zx[1]):
        ReZx=np.real(Zx)
        ImZx=np.imag(Zx)
        Zx=abs(Zx)

    if np.iscomplex(Zy[1]):
        ReZy=np.real(Zy)
        ImZy=np.imag(Zy)
        Zy=abs(Zy)

    ax4=fig.gca()
    #--- plot Zx⊥(w)
    ifxmax=np.argmax(Zx)
    ax4.plot(f[ifxmax]*1e-9, Zx[ifxmax] , marker='o', markersize=4.0, color='green')
    ax4.annotate(str(round(f[ifxmax]*1e-9,2))+ ' GHz', xy=(f[ifxmax]*1e-9,Zx[ifxmax]), xytext=(-10,5), textcoords='offset points', color='g') 
    ax4.plot(f*1e-9, Zx , lw=1, color='g', marker='s', markersize=2., label='Zx⊥(w)')
    #--- plot Zy⊥(w)
    ifymax=np.argmax(Zy)
    ax4.plot(f[ifymax]*1e-9, Zy[ifymax] , marker='o', markersize=4.0, color='magenta')
    ax4.annotate(str(round(f[ifymax]*1e-9,2))+ ' GHz', xy=(f[ifymax]*1e-9,Zy[ifymax]), xytext=(-10,5), textcoords='offset points', color='m') 
    ax4.plot(f*1e-9, Zy , lw=1, color='magenta', marker='s', markersize=2., label='Zy⊥(w)')
    ax4.set(title='Transverse impedance Z⊥(w)',
            xlabel='f [GHz]',
            ylabel='Z⊥(w) [$\Omega$]',   
            #ylim=(0.,np.maximum(max(Zx)*1.2, max(Zy)*1.2)),
            xlim=(0.,np.max(f)*1e-9)      
            )
    ax4.legend(loc='best')
    ax4.grid(True, color='gray', linewidth=0.2)

    plt.show()

    return fig

if __name__ == "__main__":
    
    out_path=os.getcwd()+'/'+'runs/out/'
    cst_path='/mnt/c/Users/elefu/Documents/CERN/WAKIS/Scripts/CST/data/taper/'
    flag_animate_Ez=True
    flag_individual_figs=False

    if flag_animate_Ez:

        #Plot Ez field animation
        animate_Ez(out_path, 
                   flag_charge_dist=True, 
                   flag_compare_cst=False, 
                   flag_transverse_field=False)
    try:
        #Plot Ez contour in the YZ plane
        contour_Ez(out_path, vmin=-1.0e5, vmax=1.0e5)
    except: print("Ez field not stored in 3D, contour will not render -> check simulation script")

    
    if os.path.exists(out_path+'wake_solver.txt'):

        # Read WAKIS results
        data=read_WAKIS(out_path)
    
        # Plot results
        fig = subplot_WAKIS(data=data, 
                            flag_charge_dist=True,
                            flag_plot_Real=True, 
                            flag_plot_Imag=True,
                            flag_plot_Abs=False
                            )

        # Save figure
        fig.savefig(out_path+'subplot_WAKIS.png',  bbox_inches='tight')
    

    if flag_individual_figs:

        # Plot in individual figures
        figs = plot_WAKIS(data=data, 
                    cst_data=read_CST(cst_path), 
                    flag_compare_cst=True, 
                    flag_normalize=False,
                    flag_charge_dist=True,
                    flag_plot_Real=True, 
                    flag_plot_Imag=True,
                    flag_plot_Abs=False
                    )

        figs[0].savefig(out_path+'longWP.png', bbox_inches='tight')
        figs[1].savefig(out_path+'longZ.png',  bbox_inches='tight')
        figs[2].savefig(out_path+'transWP.png',  bbox_inches='tight')
        figs[3].savefig(out_path+'transZ.png',  bbox_inches='tight')

        if len(figs) > 4:
            figs[4].savefig(out_path+'charge_dist')
        